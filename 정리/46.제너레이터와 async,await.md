# 제너레이터와 async / await
## 1. 제너레이터란?
코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수이다.
1) 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.
2) 제너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다.
3) 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.

## 2. 제너레이터 함수의 정의
제너레이터 함수는 function* 키워드로 선언하고 하나 이상의 yield 표현식을 포함한다.

    function* getDecFunc() {
        yield 1;
    }

    const getExpFunc = function* () {
        yield 1;
    };

    const obj = {
        * getObjMethod() {
            yield 1;
        }
    };

    class MyClass {
        * genClsMethod() {
            yield 1;
        }
    }

*의 위치는 function 키워드와 함수 이름 사이라면 어디든지 상관 없다.

function* getFunc() {}

function * getFunc() {}

function *getFunc() {}

function*getFunc() {}

또 제너레이터 함수는 화살표 함수로 정의할 수 없고, new 연산자와 함께 생성자 함수로 호출할 수 없다.

## 3. 제너레이터 객체
제너레이터 함수를 호출하면 일반 함수처럼 함수 코드 블록을 실행하는 것이 아니라 제너레이터 객체를 생성해 반환한다. 이때 반환된 제너레이터 객체는 이터러블이면서 이터레이터이다.

    function* getFunc() {
        yield 1;
        yield 2;
        yield 3;
    }

    const generator = getFunc();
    console.log(Symbol.iterator in generator);  //true
    console.log('nexy' in generator);  //true

제너레이터 객체는 이터레이터이지만 이터레이터에는 없는 return, throw 메서드를 갖는다. 

## 4. 제너레이터의 일시 중지와 재개
제너레이터 객체의 next 메서드를 호출하여 제너레이터 함수의 코드 블록을 실행한다. 이때 일반 함수처럼 한 번에 코드 블록을 일괄 실행하는 것이 아니라 yield 표현식까지만 실행한다.

yield 키워드는 제너레이터 함수의 실행을 일시 중지시키거나 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 반환한다.

    function* getFunc() {
        yield 1;
        yield 2;
        yield 3;
    }

    const generator = getFunc();
    console.log(generator.next());  //{value:1, done:false}
    console.log(generator.next());  //{value:2, done:false}
    console.log(generator.next());  //{value:3, done:false}
    console.log(generator.next());  //{value:undefined, done:true}

## 5. 제너레이터의 활용
__1)이터러블 구현__ : 제너레이터 함수를 사용하면 간단히 이터러블을 구현할 수 있다.

    const infiniteFibonacci = (function () {
        let [pre, cur] = [0, 1];

        return {
            [Symbol.iterator]() {return this;},
            next() {
                [pre, cur] = [cur, pre+cur];
                return {value: cur};
            }
        };
    }());

    for(const num of infiniteFibonacci){
        if(num > 10000) break;
        console.log(num);  //1 2 3 5 8 .....
    }
__2)비동기 처리__ : 제너레이터 함수는 프로미스의 후속처리 메서드 없이 비동기 처리 결과를 반환하도록 구현할 수 있다.

    const fetch = require('non-fetch');

    const async = generatorFunc => {  //2
        const generator = generatorFunc();

        const onResolved = arg => {
            const result = generator.next(arg);  //5

            return result.done
            ? result.value  //9
            : result.value.then(res => onResolved(res));  //7
            
        };
        return onResolved;  //3
    };

    (async(function* fetchTodo() {  //1
        const url = 'https://jsonplaceholder.typicode.com/todos/1';
        const resp = yield fetch(url);  //6
        const todo = yield resp.json();  //8
        console.log(todo);
    })());  //4
